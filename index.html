<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KiCad Image to Footprint Converter</title>
    <meta name="description" content="Convert images to KiCad silkscreen footprints with dithering algorithms">
    <meta name="author" content="i2cjak">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            margin-bottom: 10px;
            color: #00d4ff;
        }

        .subtitle {
            color: #888;
            margin-bottom: 15px;
        }

        .social-links {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
        }

        .social-links a {
            color: #00d4ff;
            text-decoration: none;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: color 0.2s;
        }

        .social-links a:hover {
            color: #fff;
        }

        .social-links svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #0f3460;
        }

        .panel h2 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 1.1rem;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.9rem;
        }

        .control-group input[type="number"],
        .control-group input[type="text"],
        .control-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #0f3460;
            border-radius: 6px;
            background: #1a1a2e;
            color: #eee;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        .control-group .value-display {
            text-align: right;
            font-size: 0.85rem;
            color: #00d4ff;
            margin-top: 3px;
        }

        .drop-zone {
            border: 2px dashed #0f3460;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
        }

        .drop-zone p {
            color: #888;
            margin-bottom: 10px;
        }

        .drop-zone .hint {
            font-size: 0.8rem;
            color: #666;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #00d4ff;
            color: #1a1a2e;
        }

        .btn-primary:hover:not(:disabled) {
            background: #00a8cc;
        }

        .btn-secondary {
            background: #0f3460;
            color: #eee;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #1a4a7a;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .canvas-container {
            position: relative;
            background: #0d0d1a;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }

        .canvas-container canvas {
            max-width: 100%;
            max-height: 400px;
            image-rendering: pixelated;
        }

        .canvas-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            color: #888;
        }

        .output-section {
            margin-top: 20px;
        }

        .output-textarea {
            width: 100%;
            height: 200px;
            background: #0d0d1a;
            border: 1px solid #0f3460;
            border-radius: 8px;
            color: #0f0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.8rem;
            padding: 15px;
            resize: vertical;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-item {
            background: #1a1a2e;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-item .value {
            font-size: 1.2rem;
            color: #00d4ff;
            font-weight: bold;
        }

        .stat-item .label {
            font-size: 0.75rem;
            color: #888;
            margin-top: 2px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #00d4ff;
        }

        .hidden-input {
            display: none;
        }

        .info-box {
            background: #0f3460;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #aaa;
        }

        .info-box strong {
            color: #00d4ff;
        }

        /* Progress indicator */
        .progress-container {
            margin-top: 15px;
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-bar {
            height: 8px;
            background: #0d0d1a;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            border-radius: 4px;
            transition: width 0.1s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 0.8rem;
            color: #888;
            text-align: center;
        }

        /* Status indicator */
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            background: #0f3460;
            color: #888;
        }

        .status-badge.processing {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
        }

        .status-badge.success {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }

        .spinner {
            width: 12px;
            height: 12px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Footer */
        footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #0f3460;
            text-align: center;
            color: #666;
            font-size: 0.8rem;
        }

        footer a {
            color: #00d4ff;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .references {
            margin-top: 15px;
            font-size: 0.75rem;
        }

        .references h4 {
            color: #888;
            margin-bottom: 8px;
            font-weight: normal;
        }

        .references ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>KiCad Image to Footprint Converter</h1>
            <p class="subtitle">Convert images to KiCad silkscreen footprints with dithering</p>
            <div class="social-links">
                <a href="https://x.com/i2cjak" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
                    @i2cjak
                </a>
                <a href="https://github.com/i2cjak/KiCadDithering" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
                    Source
                </a>
            </div>
        </header>

        <div class="main-grid">
            <!-- Controls Panel -->
            <div class="panel">
                <h2>Settings</h2>

                <div class="drop-zone" id="dropZone">
                    <p>Drop image here</p>
                    <p class="hint">or click to select / Ctrl+V to paste</p>
                </div>
                <input type="file" id="fileInput" class="hidden-input" accept="image/*">

                <div class="control-group">
                    <label>Dithering Algorithm</label>
                    <select id="algorithm">
                        <option value="threshold">Threshold (Simple)</option>
                        <option value="random">Random Noise</option>
                        <option value="bayer2">Bayer 2x2</option>
                        <option value="bayer4">Bayer 4x4</option>
                        <option value="bayer8" selected>Bayer 8x8</option>
                        <option value="floydSteinberg">Floyd-Steinberg</option>
                        <option value="atkinson">Atkinson</option>
                        <option value="jarvis">Jarvis-Judice-Ninke</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Threshold</label>
                    <input type="range" id="threshold" min="0" max="1" step="0.01" value="0.5">
                    <div class="value-display" id="thresholdValue">0.50</div>
                </div>

                <div class="control-group">
                    <label>Pixel Size (mm)</label>
                    <input type="number" id="pixelSize" value="0.2" min="0.1" max="2" step="0.05">
                    <div class="info-box">
                        <strong>Manufacturing minimums:</strong><br>
                        Most fabs: 0.15mm<br>
                        Recommended: 0.2-0.3mm
                    </div>
                </div>

                <div class="control-group">
                    <label>Output Width (pixels)</label>
                    <input type="number" id="outputWidth" value="100" min="10" max="500" step="1">
                </div>

                <div class="control-group">
                    <label>Footprint Name</label>
                    <input type="text" id="footprintName" value="ImageLogo">
                </div>

                <div class="control-group">
                    <label>Library Name</label>
                    <input type="text" id="libraryName" value="Custom">
                </div>

                <div class="control-group">
                    <label>Layer</label>
                    <select id="layer">
                        <option value="F.SilkS" selected>F.SilkS (Front Silkscreen)</option>
                        <option value="B.SilkS">B.SilkS (Back Silkscreen)</option>
                        <option value="F.Cu">F.Cu (Front Copper)</option>
                        <option value="B.Cu">B.Cu (Back Copper)</option>
                    </select>
                </div>

                <div class="control-group checkbox-group">
                    <input type="checkbox" id="invertImage">
                    <label for="invertImage">Invert Image</label>
                </div>

                <div class="control-group checkbox-group">
                    <input type="checkbox" id="gammaCorrect" checked>
                    <label for="gammaCorrect">Gamma Correction (sRGB)</label>
                </div>

                <div class="btn-group" style="margin-top: 20px;">
                    <button class="btn btn-primary" id="generateBtn">Generate Footprint</button>
                </div>

                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text" id="progressText">Processing...</div>
                </div>
            </div>

            <!-- Original Image Preview -->
            <div class="panel">
                <h2>Original Image</h2>
                <div class="canvas-container">
                    <canvas id="originalCanvas"></canvas>
                    <span class="canvas-label">Original</span>
                </div>

                <div class="stats" id="originalStats">
                    <div class="stat-item">
                        <div class="value" id="origWidth">-</div>
                        <div class="label">Width (px)</div>
                    </div>
                    <div class="stat-item">
                        <div class="value" id="origHeight">-</div>
                        <div class="label">Height (px)</div>
                    </div>
                </div>
            </div>

            <!-- Dithered Preview -->
            <div class="panel">
                <h2>Dithered Preview</h2>
                <div class="canvas-container">
                    <canvas id="ditheredCanvas"></canvas>
                    <span class="canvas-label" id="ditheredLabel">Dithered</span>
                </div>

                <div class="stats" id="ditheredStats">
                    <div class="stat-item">
                        <div class="value" id="outWidth">-</div>
                        <div class="label">Width (px)</div>
                    </div>
                    <div class="stat-item">
                        <div class="value" id="outHeight">-</div>
                        <div class="label">Height (px)</div>
                    </div>
                    <div class="stat-item">
                        <div class="value" id="blackPixels">-</div>
                        <div class="label">Black Pixels</div>
                    </div>
                    <div class="stat-item">
                        <div class="value" id="physicalSize">-</div>
                        <div class="label">Physical Size (mm)</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Output Section -->
        <div class="panel output-section">
            <h2>
                KiCad Footprint Output
                <span class="status-badge" id="statusBadge">Ready</span>
            </h2>
            <div class="btn-group" style="margin-bottom: 15px;">
                <button class="btn btn-primary" id="copyBtn">Copy to Clipboard</button>
                <button class="btn btn-secondary" id="downloadBtn">Download .kicad_mod</button>
            </div>
            <textarea class="output-textarea" id="output" readonly placeholder="Generated footprint will appear here..."></textarea>
        </div>

        <footer>
            <p>Made by <a href="https://x.com/i2cjak" target="_blank" rel="noopener">@i2cjak</a></p>
            <div class="references">
                <h4>References & Credits</h4>
                <ul>
                    <li><a href="https://dev-docs.kicad.org/en/file-formats/sexpr-footprint/" target="_blank" rel="noopener">KiCad File Format Docs</a></li>
                    <li><a href="https://surma.dev/things/ditherpunk/" target="_blank" rel="noopener">Ditherpunk by Surma</a></li>
                </ul>
            </div>
        </footer>
    </div>

    <script>
        // Initialize Web Worker
        let worker = null;
        let workerSupported = typeof Worker !== 'undefined';

        if (workerSupported) {
            try {
                worker = new Worker('worker.js');
                worker.onmessage = handleWorkerMessage;
                worker.onerror = (e) => {
                    console.warn('Worker error, falling back to main thread:', e);
                    workerSupported = false;
                };
            } catch (e) {
                console.warn('Worker init failed, using main thread:', e);
                workerSupported = false;
            }
        }

        // Bayer matrices (for fallback)
        const BAYER_2 = [[0, 2], [3, 1]];
        const BAYER_4 = [[0, 8, 2, 10], [12, 4, 14, 6], [3, 11, 1, 9], [15, 7, 13, 5]];
        const BAYER_8 = [
            [0, 32, 8, 40, 2, 34, 10, 42], [48, 16, 56, 24, 50, 18, 58, 26],
            [12, 44, 4, 36, 14, 46, 6, 38], [60, 28, 52, 20, 62, 30, 54, 22],
            [3, 35, 11, 43, 1, 33, 9, 41], [51, 19, 59, 27, 49, 17, 57, 25],
            [15, 47, 7, 39, 13, 45, 5, 37], [63, 31, 55, 23, 61, 29, 53, 21]
        ];

        const FLOYD_STEINBERG = [[1, 0, 7/16], [-1, 1, 3/16], [0, 1, 5/16], [1, 1, 1/16]];
        const ATKINSON = [[1, 0, 1/8], [2, 0, 1/8], [-1, 1, 1/8], [0, 1, 1/8], [1, 1, 1/8], [0, 2, 1/8]];
        const JARVIS = [
            [1, 0, 7/48], [2, 0, 5/48], [-2, 1, 3/48], [-1, 1, 5/48], [0, 1, 7/48],
            [1, 1, 5/48], [2, 1, 3/48], [-2, 2, 1/48], [-1, 2, 3/48], [0, 2, 5/48], [1, 2, 3/48], [2, 2, 1/48]
        ];

        // State
        let originalImage = null;
        let ditheredData = null;
        let currentOutputWidth = 0;
        let currentOutputHeight = 0;
        let isProcessing = false;

        // DOM elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const originalCanvas = document.getElementById('originalCanvas');
        const ditheredCanvas = document.getElementById('ditheredCanvas');
        const outputTextarea = document.getElementById('output');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const statusBadge = document.getElementById('statusBadge');
        const generateBtn = document.getElementById('generateBtn');

        // Utility functions
        function generateUUID() {
            if (crypto.randomUUID) return crypto.randomUUID();
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }

        function srgbToLinear(value) {
            return value <= 0.04045 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);
        }

        function imageToGrayscale(imageData, width, height, gammaCorrect) {
            const gray = new Float32Array(width * height);
            for (let i = 0; i < width * height; i++) {
                const r = imageData[i * 4] / 255;
                const g = imageData[i * 4 + 1] / 255;
                const b = imageData[i * 4 + 2] / 255;
                gray[i] = gammaCorrect
                    ? 0.2126 * srgbToLinear(r) + 0.7152 * srgbToLinear(g) + 0.0722 * srgbToLinear(b)
                    : 0.299 * r + 0.587 * g + 0.114 * b;
            }
            return gray;
        }

        // Dithering (fallback for no worker)
        function thresholdDither(gray, width, height, threshold) {
            const result = new Uint8Array(width * height);
            for (let i = 0; i < gray.length; i++) result[i] = gray[i] > threshold ? 255 : 0;
            return result;
        }

        function randomDither(gray, width, height, threshold) {
            const result = new Uint8Array(width * height);
            for (let i = 0; i < gray.length; i++) {
                result[i] = (gray[i] + (Math.random() - 0.5) * 0.5) > threshold ? 255 : 0;
            }
            return result;
        }

        function bayerDither(gray, width, height, matrix, threshold) {
            const result = new Uint8Array(width * height);
            const size = matrix.length, maxVal = size * size;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = y * width + x;
                    const bayerValue = matrix[y % size][x % size] / maxVal - 0.5;
                    result[i] = (gray[i] + bayerValue * (1 - threshold)) > threshold ? 255 : 0;
                }
            }
            return result;
        }

        function errorDiffusionDither(gray, width, height, kernel, threshold) {
            const buffer = Float32Array.from(gray);
            const result = new Uint8Array(width * height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = y * width + x;
                    const newPixel = buffer[i] > threshold ? 1 : 0;
                    result[i] = newPixel * 255;
                    const error = buffer[i] - newPixel;
                    for (const [dx, dy, weight] of kernel) {
                        const nx = x + dx, ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            buffer[ny * width + nx] += error * weight;
                        }
                    }
                }
            }
            return result;
        }

        function applyDithering(gray, width, height, algorithm, threshold) {
            switch (algorithm) {
                case 'threshold': return thresholdDither(gray, width, height, threshold);
                case 'random': return randomDither(gray, width, height, threshold);
                case 'bayer2': return bayerDither(gray, width, height, BAYER_2, threshold);
                case 'bayer4': return bayerDither(gray, width, height, BAYER_4, threshold);
                case 'bayer8': return bayerDither(gray, width, height, BAYER_8, threshold);
                case 'floydSteinberg': return errorDiffusionDither(gray, width, height, FLOYD_STEINBERG, threshold);
                case 'atkinson': return errorDiffusionDither(gray, width, height, ATKINSON, threshold);
                case 'jarvis': return errorDiffusionDither(gray, width, height, JARVIS, threshold);
                default: return thresholdDither(gray, width, height, threshold);
            }
        }

        // Progress and status helpers
        function showProgress(show) {
            progressContainer.classList.toggle('active', show);
        }

        function updateProgress(percent, text) {
            progressFill.style.width = percent + '%';
            progressText.textContent = text;
        }

        function setStatus(status, text) {
            statusBadge.className = 'status-badge ' + status;
            statusBadge.innerHTML = status === 'processing'
                ? '<span class="spinner"></span>' + text
                : text;
        }

        // Worker message handler
        function handleWorkerMessage(e) {
            const { type, ...data } = e.data;

            switch (type) {
                case 'status':
                    setStatus('processing', data.message);
                    break;

                case 'progress':
                    updateProgress(data.percent, `Generating: ${data.current.toLocaleString()} / ${data.total.toLocaleString()} pixels`);
                    break;

                case 'dithered':
                    ditheredData = data.ditheredData;
                    currentOutputWidth = data.width;
                    currentOutputHeight = data.height;
                    renderDitheredPreview(data.ditheredData, data.width, data.height, data.blackCount);
                    break;

                case 'generated':
                    outputTextarea.value = data.footprint;
                    showProgress(false);
                    setStatus('success', 'Complete');
                    generateBtn.disabled = false;
                    isProcessing = false;
                    break;
            }
        }

        // Image loading
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    updateOriginalPreview();
                    processImage();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updateOriginalPreview() {
            if (!originalImage) return;
            const ctx = originalCanvas.getContext('2d');
            originalCanvas.width = originalImage.width;
            originalCanvas.height = originalImage.height;
            ctx.drawImage(originalImage, 0, 0);
            document.getElementById('origWidth').textContent = originalImage.width;
            document.getElementById('origHeight').textContent = originalImage.height;
        }

        function processImage() {
            if (!originalImage) return;

            const outputWidth = parseInt(document.getElementById('outputWidth').value);
            const scale = outputWidth / originalImage.width;
            const outputHeight = Math.round(originalImage.height * scale);

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = outputWidth;
            tempCanvas.height = outputHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = true;
            tempCtx.drawImage(originalImage, 0, 0, outputWidth, outputHeight);

            const imageData = tempCtx.getImageData(0, 0, outputWidth, outputHeight);
            const gammaCorrect = document.getElementById('gammaCorrect').checked;
            const invert = document.getElementById('invertImage').checked;
            const algorithm = document.getElementById('algorithm').value;
            const threshold = parseFloat(document.getElementById('threshold').value);

            if (workerSupported && worker) {
                worker.postMessage({
                    type: 'dither',
                    data: {
                        imageData: imageData.data,
                        width: outputWidth,
                        height: outputHeight,
                        algorithm,
                        threshold,
                        gammaCorrect,
                        invert
                    }
                });
            } else {
                // Fallback to main thread
                let gray = imageToGrayscale(imageData.data, outputWidth, outputHeight, gammaCorrect);
                if (invert) for (let i = 0; i < gray.length; i++) gray[i] = 1 - gray[i];

                ditheredData = applyDithering(gray, outputWidth, outputHeight, algorithm, threshold);
                currentOutputWidth = outputWidth;
                currentOutputHeight = outputHeight;

                let blackCount = 0;
                for (let i = 0; i < ditheredData.length; i++) if (ditheredData[i] === 0) blackCount++;

                renderDitheredPreview(ditheredData, outputWidth, outputHeight, blackCount);
            }
        }

        function renderDitheredPreview(data, width, height, blackCount) {
            ditheredCanvas.width = width;
            ditheredCanvas.height = height;
            const ctx = ditheredCanvas.getContext('2d');
            const resultImageData = ctx.createImageData(width, height);

            for (let i = 0; i < data.length; i++) {
                resultImageData.data[i * 4] = data[i];
                resultImageData.data[i * 4 + 1] = data[i];
                resultImageData.data[i * 4 + 2] = data[i];
                resultImageData.data[i * 4 + 3] = 255;
            }
            ctx.putImageData(resultImageData, 0, 0);

            const pixelSize = parseFloat(document.getElementById('pixelSize').value);
            document.getElementById('outWidth').textContent = width;
            document.getElementById('outHeight').textContent = height;
            document.getElementById('blackPixels').textContent = blackCount.toLocaleString();
            document.getElementById('physicalSize').textContent =
                `${(width * pixelSize).toFixed(1)} x ${(height * pixelSize).toFixed(1)}`;
        }

        // Footprint generation
        function generateFootprint() {
            if (!ditheredData) {
                alert('Please load an image first');
                return;
            }

            if (isProcessing) return;
            isProcessing = true;
            generateBtn.disabled = true;

            const pixelSize = parseFloat(document.getElementById('pixelSize').value);
            const footprintName = document.getElementById('footprintName').value || 'ImageLogo';
            const libraryName = document.getElementById('libraryName').value || 'Custom';
            const layer = document.getElementById('layer').value;

            showProgress(true);
            updateProgress(0, 'Starting...');
            setStatus('processing', 'Generating...');

            if (workerSupported && worker) {
                worker.postMessage({
                    type: 'generate',
                    data: {
                        ditheredData: ditheredData,
                        width: currentOutputWidth,
                        height: currentOutputHeight,
                        options: { pixelSize, footprintName, libraryName, layer }
                    }
                });
            } else {
                // Fallback with chunked processing using setTimeout
                generateFootprintChunked(pixelSize, footprintName, libraryName, layer);
            }
        }

        function generateFootprintChunked(pixelSize, footprintName, libraryName, layer) {
            const width = currentOutputWidth;
            const height = currentOutputHeight;
            const centerX = (width * pixelSize) / 2;
            const centerY = (height * pixelSize) / 2;

            // Collect black pixels
            const blackPixels = [];
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (ditheredData[y * width + x] === 0) blackPixels.push({ x, y });
                }
            }

            const totalPixels = blackPixels.length;
            const parts = [];

            // Header
            parts.push(`(footprint "${libraryName}:${footprintName}"
    (version 20241229)
    (generator "KiCadDithering")
    (generator_version "1.0")
    (layer "F.Cu")
    (uuid "${generateUUID()}")
    (at 0 0)
    (property "Reference" "G***"
        (at 0 ${(-centerY - 2).toFixed(2)} 0)
        (layer "${layer}")
        (uuid "${generateUUID()}")
        (effects
            (font (size 1.5 1.5) (thickness 0.3))
        )
    )
    (property "Value" "${footprintName}"
        (at 0 ${(centerY + 2).toFixed(2)} 0)
        (layer "${layer}")
        (hide yes)
        (uuid "${generateUUID()}")
        (effects
            (font (size 1.5 1.5) (thickness 0.3))
        )
    )
    (property "Datasheet" ""
        (at 0 0 0)
        (layer "F.Fab")
        (hide yes)
        (uuid "${generateUUID()}")
        (effects
            (font (size 1.27 1.27) (thickness 0.15))
        )
    )
    (property "Description" "Image converted to footprint"
        (at 0 0 0)
        (layer "F.Fab")
        (hide yes)
        (uuid "${generateUUID()}")
        (effects
            (font (size 1.27 1.27) (thickness 0.15))
        )
    )
    (attr board_only exclude_from_pos_files exclude_from_bom)`);

            let index = 0;
            const chunkSize = 500;

            function processChunk() {
                const endIndex = Math.min(index + chunkSize, totalPixels);

                for (; index < endIndex; index++) {
                    const { x, y } = blackPixels[index];
                    const left = (x * pixelSize - centerX).toFixed(6);
                    const right = ((x + 1) * pixelSize - centerX).toFixed(6);
                    const top = (y * pixelSize - centerY).toFixed(6);
                    const bottom = ((y + 1) * pixelSize - centerY).toFixed(6);

                    parts.push(`
    (fp_poly
        (pts
            (xy ${left} ${top}) (xy ${right} ${top}) (xy ${right} ${bottom}) (xy ${left} ${bottom})
        )
        (stroke (width 0) (type solid))
        (fill yes)
        (layer "${layer}")
        (uuid "${generateUUID()}")
    )`);
                }

                const percent = Math.round((index / totalPixels) * 100);
                updateProgress(percent, `Generating: ${index.toLocaleString()} / ${totalPixels.toLocaleString()} pixels`);

                if (index < totalPixels) {
                    setTimeout(processChunk, 0);
                } else {
                    parts.push(`
    (embedded_fonts no)
)`);
                    outputTextarea.value = parts.join('');
                    showProgress(false);
                    setStatus('success', 'Complete');
                    generateBtn.disabled = false;
                    isProcessing = false;
                }
            }

            setTimeout(processChunk, 0);
        }

        // Event listeners
        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) loadImage(file);
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadImage(e.target.files[0]);
        });

        document.addEventListener('paste', (e) => {
            for (const item of e.clipboardData.items) {
                if (item.type.startsWith('image/')) {
                    loadImage(item.getAsFile());
                    break;
                }
            }
        });

        // Debounce helper
        function debounce(fn, delay) {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => fn(...args), delay);
            };
        }

        const debouncedProcess = debounce(processImage, 100);

        document.getElementById('algorithm').addEventListener('change', processImage);
        document.getElementById('threshold').addEventListener('input', function() {
            document.getElementById('thresholdValue').textContent = parseFloat(this.value).toFixed(2);
            debouncedProcess();
        });
        document.getElementById('outputWidth').addEventListener('change', processImage);
        document.getElementById('pixelSize').addEventListener('change', () => {
            if (ditheredData) {
                const pixelSize = parseFloat(document.getElementById('pixelSize').value);
                document.getElementById('physicalSize').textContent =
                    `${(currentOutputWidth * pixelSize).toFixed(1)} x ${(currentOutputHeight * pixelSize).toFixed(1)}`;
            }
        });
        document.getElementById('invertImage').addEventListener('change', processImage);
        document.getElementById('gammaCorrect').addEventListener('change', processImage);

        generateBtn.addEventListener('click', generateFootprint);

        document.getElementById('copyBtn').addEventListener('click', async () => {
            const text = outputTextarea.value;
            if (!text) return;

            try {
                await navigator.clipboard.writeText(text);
                const btn = document.getElementById('copyBtn');
                const orig = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = orig, 2000);
            } catch {
                outputTextarea.select();
                document.execCommand('copy');
            }
        });

        document.getElementById('downloadBtn').addEventListener('click', () => {
            const content = outputTextarea.value;
            if (!content) {
                alert('Generate a footprint first');
                return;
            }
            const name = document.getElementById('footprintName').value || 'ImageLogo';
            const blob = new Blob([content], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${name}.kicad_mod`;
            a.click();
            URL.revokeObjectURL(a.href);
        });
    </script>
</body>
</html>
